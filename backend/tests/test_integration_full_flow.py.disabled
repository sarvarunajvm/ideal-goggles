"""
Integration tests for complete application workflows.
"""

import pytest
import asyncio
import tempfile
import shutil
from pathlib import Path
from unittest.mock import patch, MagicMock
from fastapi.testclient import TestClient
import sys
import os

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from src.main import app


class TestIntegrationFullFlow:
    """Integration tests for complete workflows."""

    @pytest.fixture
    def client(self):
        """Create test client."""
        return TestClient(app)

    @pytest.fixture
    def temp_dir(self):
        """Create temporary directory for testing."""
        temp_dir = tempfile.mkdtemp()
        yield temp_dir
        shutil.rmtree(temp_dir, ignore_errors=True)

    def test_health_check_workflow(self, client):
        """Test complete health check workflow."""
        # Basic health check
        response = client.get("/health")
        assert response.status_code == 200
        basic_health = response.json()
        assert basic_health["status"] in ["healthy", "degraded"]

        # Detailed health check
        response = client.get("/health/detailed")
        assert response.status_code == 200
        detailed_health = response.json()
        assert "diagnostics" in detailed_health

        # Readiness check
        response = client.get("/health/ready")
        assert response.status_code == 200
        ready = response.json()
        assert isinstance(ready["ready"], bool)

        # Liveness check
        response = client.get("/health/live")
        assert response.status_code == 200
        live = response.json()
        assert live["alive"] is True

    def test_configuration_workflow(self, client, temp_dir):
        """Test configuration management workflow."""
        # Get current config
        response = client.get("/config")
        assert response.status_code == 200
        original_config = response.json()

        # Add a root directory
        new_root = str(Path(temp_dir) / "photos")
        os.makedirs(new_root, exist_ok=True)

        response = client.post("/config/roots", json={
            "path": new_root,
            "recursive": True
        })
        assert response.status_code == 200

        # Update config settings
        response = client.put("/config", json={
            "enable_ocr": True,
            "enable_face_detection": False,
            "thumbnail_size": 256
        })
        assert response.status_code == 200

        # Get updated config
        response = client.get("/config")
        assert response.status_code == 200
        updated_config = response.json()

        # Verify changes
        assert len(updated_config["root_directories"]) > len(original_config.get("root_directories", []))

    def test_indexing_and_search_workflow(self, client):
        """Test indexing followed by search workflow."""
        # Stop any existing indexing
        client.post("/index/stop")

        # Start indexing
        response = client.post("/index/start", json={"full": False})
        assert response.status_code in [200, 409]

        # Check status
        response = client.get("/index/status")
        assert response.status_code == 200
        status = response.json()
        assert status["status"] in ["idle", "indexing", "completed", "error"]

        # Get stats
        response = client.get("/index/stats")
        assert response.status_code == 200
        stats = response.json()
        assert "database_stats" in stats
        assert "index_stats" in stats

        # Perform text search
        response = client.get("/search", params={
            "q": "test search",
            "limit": 10
        })
        assert response.status_code == 200
        search_results = response.json()
        assert "results" in search_results
        assert isinstance(search_results["results"], list)

        # Stop indexing
        response = client.post("/index/stop")
        assert response.status_code == 200

    def test_semantic_search_workflow(self, client):
        """Test semantic search workflow."""
        # Perform semantic search
        response = client.post("/search/semantic", json={
            "query": "beautiful sunset over ocean",
            "limit": 20
        })
        assert response.status_code == 200
        results = response.json()

        assert "results" in results
        assert "total" in results
        assert "query" in results
        assert results["query"] == "beautiful sunset over ocean"

        # Search with filters
        response = client.post("/search/semantic", json={
            "query": "family gathering",
            "limit": 10,
            "date_from": "2024-01-01",
            "date_to": "2024-12-31"
        })
        assert response.status_code == 200

    def test_people_management_workflow(self, client):
        """Test people detection and management workflow."""
        # Get all people
        response = client.get("/people")
        assert response.status_code == 200
        people = response.json()
        assert isinstance(people, list)

        # If there are people, test getting details
        if people:
            person_id = people[0]["id"]

            # Get person details
            response = client.get(f"/people/{person_id}")
            assert response.status_code == 200
            person = response.json()
            assert person["id"] == person_id

            # Get person's photos
            response = client.get(f"/people/{person_id}/photos")
            assert response.status_code == 200
            photos = response.json()
            assert isinstance(photos, list)

    def test_concurrent_operations(self, client):
        """Test handling of concurrent operations."""
        import concurrent.futures

        def health_check():
            return client.get("/health")

        def search_text(query):
            return client.get("/search", params={"q": query, "limit": 5})

        def get_status():
            return client.get("/index/status")

        # Execute concurrent requests
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            futures = []

            # Mix different types of requests
            for i in range(3):
                futures.append(executor.submit(health_check))
                futures.append(executor.submit(search_text, f"query_{i}"))
                futures.append(executor.submit(get_status))

            # Collect results
            results = [f.result() for f in concurrent.futures.as_completed(futures)]

        # All requests should succeed
        for result in results:
            assert result.status_code == 200

    def test_error_recovery_workflow(self, client):
        """Test error handling and recovery."""
        # Test invalid search parameters
        response = client.get("/search", params={
            "q": "",  # Empty query
            "limit": -1  # Invalid limit
        })
        assert response.status_code in [400, 422]

        # Test invalid configuration
        response = client.put("/config", json={
            "invalid_field": "invalid_value"
        })
        # Should handle gracefully
        assert response.status_code in [200, 400, 422]

        # Test non-existent person
        response = client.get("/people/99999999")
        assert response.status_code in [404, 200]  # 404 or empty result

        # System should still be functional after errors
        response = client.get("/health")
        assert response.status_code == 200

    @patch('src.api.indexing._indexing_state')
    def test_indexing_state_management(self, mock_state, client):
        """Test indexing state transitions."""
        # Test state transitions
        states = ["idle", "indexing", "completed", "error"]

        for state in states:
            mock_state["status"] = state
            response = client.get("/index/status")
            assert response.status_code == 200
            status = response.json()
            assert status["status"] == state

    def test_pagination_workflow(self, client):
        """Test pagination across different endpoints."""
        # Test search pagination
        page1 = client.get("/search", params={
            "q": "test",
            "limit": 5,
            "offset": 0
        })
        assert page1.status_code == 200

        page2 = client.get("/search", params={
            "q": "test",
            "limit": 5,
            "offset": 5
        })
        assert page2.status_code == 200

        # Results should be different (if there are results)
        if page1.json()["results"] and page2.json()["results"]:
            # Check that results are different
            page1_ids = [r["photo_id"] for r in page1.json()["results"]]
            page2_ids = [r["photo_id"] for r in page2.json()["results"]]
            assert page1_ids != page2_ids or len(page1_ids) == 0

    def test_complete_user_journey(self, client, temp_dir):
        """Test a complete user journey through the application."""
        # Step 1: Check system health
        health = client.get("/health")
        assert health.status_code == 200

        # Step 2: Configure directories
        config = client.get("/config")
        assert config.status_code == 200

        # Step 3: Start indexing
        client.post("/index/stop")  # Ensure clean state
        index_start = client.post("/index/start", json={"full": False})
        assert index_start.status_code in [200, 409]

        # Step 4: Check indexing status
        status = client.get("/index/status")
        assert status.status_code == 200

        # Step 5: Perform searches
        text_search = client.get("/search", params={"q": "vacation", "limit": 10})
        assert text_search.status_code == 200

        semantic_search = client.post("/search/semantic", json={
            "query": "happy moments",
            "limit": 10
        })
        assert semantic_search.status_code == 200

        # Step 6: Check people
        people = client.get("/people")
        assert people.status_code == 200

        # Step 7: Stop indexing
        index_stop = client.post("/index/stop")
        assert index_stop.status_code == 200

        # Step 8: Final health check
        final_health = client.get("/health")
        assert final_health.status_code == 200